/* File: fib.jsf
 * Authors: Palmer Truelson and Aza Raskin
 * Company: Massive Health, LLC
 * Licence: $LICENSE
 * About: Fireworks Interface Builder.  A fireworks extension script that
 *  exports json data to be used as interface description for Titanium
 *  mobile apps.
 */

// Make sure we have dojo
try { dojo.require; } catch (e)
    { fw.runScript(fw.currentScriptDir + "/lib/lib.js"); }

try { _.times(function() {}) } catch (e)
    { fw.runScript(fw.currentScriptDir + "/lib/underscore.js"); }

fw.runScript(fw.currentScriptDir + '/fib_helper.js')

dojo.require("dojo._base.json");

var FIB = {};

(function () {

  // CONSTS
  var VERT_SCROLL_THRESHOLD = 480;
  var HORIZ_SCROLL_THRESHOLD = 320;

  // Setup.  Here comes the dom tree
  var dom = fw.getDocumentDOM();
  var sel = fw.selection;

  // Support for our hacky font renaming to get around UIFont limitation on number
  // of weights/styles per font family to 2. Used ttx to rename fonts with their
  // weights - i.e. Gotham-Bold-Italic -> GothamBoldItalic
  var hackyFonts = ['Gotham'];
  var hackyFontRename = function hackyFontRename(font) {
    for (var i = 0; i < hackyFonts.length; i++) {
      if (0 === font.indexOf(hackyFonts[i])) {
        return font.replace(/-/g,'');
      }
    }
    return font;
  }

  // our recursive means of extracting objects
  var extractObjects = function (container, pageObj) {

    // initialize pageObj if need be
    if(pageObj === undefined) {
      pageObj = {};
    }

    // *TODO handle resorting of layers so objects show up properly
    
    // function to extract those basic properties
    var extractBasics = function (obj) {

      var newObj = {};
      var new_size = FibHelper.getActualSize(obj);

      newObj.left = new_size.left;
      newObj.top = new_size.top;

      // using auto here as height and width will
      // sometimes cause the image to expanded in improper ways
      newObj.height = "auto"; 
      newObj.width = "auto";

      // get meta data out of name and GO!
      // Small chance Titanium may someday use keyword metaData
      newObj.metaData = extractMetaData(obj.name);

      // set hidden attribute
      if (newObj.metaData && !obj.visible) {
        newObj.metaData.hidden = true;
      }

      // now use meta data name if given.  Get unique if no name, or
      // empty, or doesn't exist
      if(newObj.metaData.name && 
         newObj.name != '' &&
         FibHelper.isNameUnique(newObj.metaData.name)) {

        newObj.name = newObj.metaData.name;
        delete newObj.metaData.name;
      } else {
        newObj.name = FibHelper.getUniqueName(obj);
      }
      
      // Set zIndex
      if(newObj.metaData.zIndex) {
        newObj.zIndex = newObj.metaData.zIndex;
      }
      
      // now add to name map
      FibHelper.nameMap[newObj.name] = true;

      return newObj;
    };

    var extractImageBasedObject = function (obj) {
      var newObj = extractBasics(obj);
      if(!newObj) {
        return null;
      }

      if (!newObj.metaData.type) {
        newObj.metaData.type = 'image';
      }
      newObj.image = FibHelper.imagesDir + newObj.name + '.png';
      
      // extract inactive image
      if (newObj.metaData.inactive) {
        newObj.backgroundDisabledImage = FibHelper.imagesDir + 
          newObj.metaData.inactive + '.png';
      }

      // handle case for different meta data
      var extractType = {};

      extractType['scroll'] = function() {
        newObj.name = 'scroll_view';
        newObj.width = obj.width;
        newObj.height = obj.height;

        delete newObj.image;
      };

      extractType['web'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;
        newObj.url = newObj.metaData.url;

        delete newObj.image;
      };

      extractType['button'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;
        
        newObj.backgroundImage = newObj.image;
        delete newObj.image;
      };

      extractType['switch'] = function () {
        newObj.width = obj.width;
        newObj.height = obj.height;
        newObj.value = false;
        delete newObj.image;
      };

      extractType['textfield'] = function() {

        // first export the text box
        newObj.left += 5;
        newObj.width = obj.width - 10;
        newObj.height = obj.height;

        // set background to transparent
        newObj.backgroundColor = 'transparent';

        
        // Set color from metadata
        if (newObj.metaData.color) {
          newObj.color = newObj.metaData.color;
        }
  
        // Set font from metadata
        if (newObj.metaData.font || newObj.metaData.fontsize) {
          newObj.font = {};
          if(newObj.metaData.font) {
            newObj.font.fontFamily = hackyFontRename(newObj.metaData.font);
          }
          if(newObj.metaData.fontsize) {
            newObj.font.fontSize = newObj.metaData.fontsize;
          }
        }

        delete newObj.image;
        FibHelper.exportPNG(obj, newObj.name);
        pageObj[newObj.name] = newObj;

        // then export an image behind it
        // since adding backgroundImage to a text label causes pain
        var newImgObj = extractBasics(obj);
        newImgObj.metaData.type = 'image';
        newImgObj.name = newObj.name + "_img";
        newImgObj.image = FibHelper.imagesDir + newImgObj.name + ".png";
        FibHelper.nameMap[newImgObj.name] = true;
        delete newImgObj.metaData.name;
        newObj = newImgObj;
      };
      
      extractType['textarea'] = extractType['textfield'];

      extractType['scrollable'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;
        newObj.contentWidth = 'auto';
        newObj.contentHeight = 'auto';

        if (obj.opacity != 0) {
          newObj.backgroundImage = newObj.image;
        }
        delete newObj.image;
      }

      extractType['table'] = extractType['scrollable'];

      extractType['free_image'] = function() {

        // if it's an instance, then we want to add an offset
        if (FibHelper.objType(obj) === 'Instance') {

          // get the transform
          var x = obj.transform.matrix[6];
          var y = obj.transform.matrix[7];

          // set how much to offset from the top, left
          newObj.metaData.offset = {
            x: newObj.left - x,
            y: newObj.top - y
          }
        }
      }
      
      extractType['progress'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;
        newObj.bgcolor = '#FFFFFF'; // Arbitrarily defaulted to white
        newObj.inverted = false;
        if (newObj.metaData.bgcolor) {
          newObj.bgcolor = newObj.metaData.bgcolor;
        }
        if (newObj.metaData.inverted) {
          newObj.inverted = newObj.metaData.inverted;
        }
      }

      // now run it
      if (newObj.metaData.type in extractType) {
        extractType[newObj.metaData.type]();
      }

      pageObj[newObj.name] = newObj;

      if (newObj.metaData.type != 'web' && 
          newObj.metaData.type != 'scroll') {
        FibHelper.exportPNG(obj, newObj.name);
      }

      return newObj;
    };

    // means of getting meta data out of name
    // *TODO create interface and store in symbol data.
    // using a string for this is a HACK
    var extractMetaData = function (metaString) {
      var metaData = null;
      var name;

      // null if given null
      if(!metaString || metaString === '') {
        return {};
      }

      // strip semicolons
      metaString = metaString.replace(/\;/g, "");

      if(!(metaString.match(/:/))) {
        metaString = metaString.replace(/\ /g, "_");
        return {name: metaString};
      }
      
      // try to make string safe for json input
      // THIS IS TOTALLY HACKY.  GET RID OF THIS
      // replace white space, and add quotes around all objects
      metaString = metaString.replace(/\ /g, "");
      metaString = metaString.replace(/:/g, "\":\"");
      metaString = metaString.replace(/,/g, "\",\"");
     
      // add starting and ending bracket-quotes
      metaString = "{\"" + metaString + "\"}";

      // try getting metadata.  Quite possible you could fail
      try {
        metaData = dojo.fromJson(metaString);
      } catch (e) {
        // *TODO let user know if something crappy happens when parsing
        console.log('Your Mom\'s poorly formatted string: ' + metaString)
      }
      return metaData;
    };
    FIB._extractMetaData = extractMetaData;

    // extraction functions for different types of objects stored here
    extractSwitch = {};

    // how to handle groups
    extractSwitch['Group'] = function (obj) {

      // exporting group as image for now
      return extractImageBasedObject(obj);
    };

    // How to handle Image 
    extractSwitch['Image'] = function (obj) {
      // extract as basic image for now
      return extractImageBasedObject(obj);
    };

    // How to handle Image 
    extractSwitch['Instance'] = function (obj) {
      // extract as basic image for now
      var newObj = extractImageBasedObject(obj);

      var origin_offset = {};
      return newObj;
    };

    // How to handle Layers
    extractSwitch['Layer'] = function (obj) {
      if(obj.layerType !== 'web') {
        extractObjects(obj.elems, pageObj);
      }
      return null;
    };

    // How to handle paths
    extractSwitch['Path'] = function (obj) {
      // extract as basic image for now
      return extractImageBasedObject(obj);
    };

    // How to Rectangle Primitives
    extractSwitch['RectanglePrimitive'] = function (obj) {
      // extract as basic image for now
      return extractImageBasedObject(obj);
    };

    // How to handle text objects
    extractSwitch['Text'] = function (obj) {
      var newObj = extractBasics(obj);
      if (!newObj) {
        return null;
      }
			
      newObj.width = obj.width;
      newObj.height = obj.height;
      newObj.textAlign = obj.alignment;
      newObj.color = obj.pathAttributes.fillColor;
      newObj.font = {
        fontFamily: obj.font,
        fontSize: obj.fontsize
      };

      newObj.font.fontFamily = hackyFontRename(newObj.font.fontFamily);
      
      // handle textfield... all others are labels
      if (newObj.metaData.type == 'textfield') {

        newObj.value = obj.textChars;
      } else if (newObj.metaData.type == 'textarea') {
        newObj.value = obj.textChars;
      } else {
        newObj.metaData.type = 'label';
        newObj.text = obj.textChars;
      }

      pageObj[newObj.name] = newObj;

      return newObj;
    };

    // extract switch helper
    var extractObject = function (obj) {
      var type = FibHelper.objType(obj);
      if (!(type in extractSwitch)) {
        return null;
      }
      return extractSwitch[FibHelper.objType(obj)](obj);
    };

    // wrapper for the map call of extract object
    _.map(container, extractObject);
    return pageObj;
  }
  // extractObjects added for testing purposes
  FIB._extractObjects = extractObjects;

  // What type of view are we dealing with here?
  var extractViewProps = function extractViewProps(obj_tree) {
    var props = {};

    props.metaData = {};
    props.metaData.type = 'view';

    props.backgroundColor = dom.backgroundColor;

    props.metaData.orientation = 'PORTRAIT'; 

    props.height = dom.height;
    props.width = dom.width;

    var v_max = VERT_SCROLL_THRESHOLD;
    var h_max = HORIZ_SCROLL_THRESHOLD;
    
    // *TODO make this based on meta data in png file, not a name
    if (dom.pageName.match(/TableRow$/)) {
      props.metaData.type = 'tableRow';
    }

    if (dom.width > dom.height && dom.width > h_max) {
      props.metaData.orientation = 'LANDSCAPE'; 
    }

    // add scroll view
    if (obj_tree && obj_tree.scroll_view) {
      props.metaData.type = 'scroll';
      props.contentHeight = dom.height;
      props.contentWidth = dom.width;
      props.height = obj_tree.scroll_view.height;
      props.width = obj_tree.scroll_view.width;
    }


    return props;
  };
  FIB._extractViewProps = extractViewProps;

  // The actual function you call to export a page
  FIB.exportInterface = function () {
    // get root resource directory
    if(!dom || !FibHelper.getResourceDirs()) {
      return false;
    }
    
    // delete the image directory first
    Files.deleteFileIfExisting(FibHelper.fullImagesDir); 
    Files.createDirectory(FibHelper.fullImagesDir);

    var objTree = extractObjects(dom.topLayers || dom.layers);

    objTree._props = extractViewProps(objTree);
    
    // delete scroll_view if it exists
    if (objTree.scroll_view) {
      delete objTree.scroll_view;
    }

    // Create file, then open.  Need to add test to check for file first
    // and delete if exists.
    var filename = FibHelper.getPageName() + '.json';
    
    Files.deleteFileIfExisting(FibHelper.fullStylesDir + filename);
    Files.createFile(FibHelper.fullStylesDir + filename, 'json', 'FWMX');
    var file = Files.open(FibHelper.fullStylesDir + filename, true);

    // Make sure you write text in UTF8!
    file.writeUTF8(dojo.toJson(objTree, true, '  '));
    file.close();
  };
})();

// only export if this is a test
if (fw._mockFile) {
  exports.FIB = FIB;
}

try {
  // don't run this if you're testing it
  if(!fw._mockFile) {
    var ret = FIB.exportInterface();
  }
} catch(e) {
  alert([e.lineNumber, e.message]);
};
