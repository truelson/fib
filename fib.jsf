/* File: fib.jsf
 * Authors: Palmer Truelson and Aza Raskin
 * Company: Massive Health, LLC
 * Licence: $LICENSE
 * About: Fireworks Interface Builder.  A fireworks extension script that
 *  exports json data to be used as interface description for Titanium
 *  mobile apps.
 */

// Make sure we have dojo
try { dojo.require; } catch (e)
    { fw.runScript(fw.currentScriptDir + "/lib/lib.js"); }

try { _.times(function() {}) } catch (e)
    { fw.runScript(fw.currentScriptDir + "/lib/underscore.js"); }

dojo.require("dojo._base.json");

var FIB = {};

(function () {

  // CONSTS
  var VERT_SCROLL_THRESHOLD = 480;
  var HORIZ_SCROLL_THRESHOLD = 320;

  // Setup.  Here comes the dom tree
  var dom = fw.getDocumentDOM();
  var sel = fw.selection;
  var page_name = dom.pageName.replace(/ /,'_');

  // list of resource directories we're going to get
  var resourcesDir, imagesDir, fullImagesDir, stylesDir, fullStylesDir;

  // Support for our hacky font renaming to get around UIFont limitation on number
  // of weights/styles per font family to 2. Used ttx to rename fonts with their
  // weights - i.e. Gotham-Bold-Italic -> GothamBoldItalic
  var hackyFonts = ['Gotham'];
  var hackyFontRename = function hackyFontRename(font) {
    for (var i = 0; i < hackyFonts.length; i++) {
      if (0 === font.indexOf(hackyFonts[i])) {
        return font.replace(/-/g,'');
      }
    }
    return font;
  }

  var getResourceDirs = function () {
    // *TODO Add code using filePathForSave to save a meta file object
    // that will have a stored preferences file in JSON with our 
    // preferred resource dir and other options

    // get a resources dir
    resourcesDir = fw.browseForFolderURL('Choose the App Resource Dir');
    if (resourcesDir === null) {
      return false;
    };
    resourcesDir = resourcesDir + '/';

    // set our module convenience variables
    imagesDir = 'images/' + page_name + '/';
    fullImagesDir = resourcesDir + imagesDir;
    stylesDir = 'styles/';
    fullStylesDir = resourcesDir + stylesDir;
    return true;
  }
  FIB._getResourceDirs = getResourceDirs;

  // Helpers:

  // Gets type of object from toString returned
  var objType = function(obj) {
    if (typeof obj !== 'object') {
      return null;
    }

    // *HACK here.  Use to string first to see if it returns
    // [object <type>]
    // if not, use the old type.
    // this allows us to override type in our mocks
    var name = obj.toString();
    if (!name.match(/^\[object /)) { 
      // Use the object prototype toString.  This always works.
      name = Object.prototype.toString.call(obj);
    }
    name = name.replace(/\[object /, '');
    name = name.replace(/\]/, '');
    
    return name;
  };
  FIB._objType = objType;
  
  // Get unique name for objects without names
  // adding external access to function for testing purposes
  var nameMap = {};
  var counter = {};
  var resetCounter = function () {
    counter['Text'] = 0;
    counter['Button'] = 0;
    counter['Group'] = 0;
    counter['Image'] = 0;
    counter['Instance'] = 0;
    counter['Path'] = 0;
    counter['RectanglePrimitive'] = 0;
    counter['Undefined'] = 0;
    nameMap = {};
  };
  FIB._resetCounter = resetCounter;
  resetCounter();
  
  var getUniqueName = function (obj) {
    var type = objType(obj);
    var name;
    if(type in counter) {
      counter[type]++;
      name = '__' + page_name + type + counter[type];  
    } else {
      counter['Undefined']++;
      name = '__' + page_name + 'Undefined' + counter['Undefined'];
    }
    return name;  
  };

  var isNameUnique = function (curName)
  {
    return (!(nameMap.hasOwnProperty(curName)));
  };

  var cloneAndCut = function cloneAndCut(obj) {
    var bounds;
    
    var old_selection = fw.selection;
    fw.selection = obj;

    dom.cloneSelection();
    bounds = getActualSize(obj);
    dom.clipCut();

    fw.selection = old_selection;
    
    return bounds;
  };
  FIB._cloneAndCut = cloneAndCut;

  var createAndPaste = function createAndPaste(bounds) {
    var old_dom, new_dom;

    old_dom = fw.getDocumentDOM();

    fw.createDocument();
    new_dom = fw.getDocumentDOM();

    // set the export options
    new_dom.backgroundColor = '#ffffff00';
    new_dom.exportOptions.colorMode = '32 bit';
    new_dom.exportOptions.exportFormat = 'PNG';
    new_dom.setDocumentResolution({
      pixelsPerUnit: old_dom.resolution,
      units: old_dom.resolutionUnits
    });
    
    new_dom.clipPaste('do not resample');

    var obj = new_dom.layers[0].elems[0];
    bounds = getActualSize(obj);

    // set the canvas size to the selection size and paste
    new_dom.setDocumentCanvasSize(bounds, true);

    return new_dom;
  };
  FIB._createAndPaste = createAndPaste;

  // exporting files via dom export elements
  var exportPNG = function (obj, name) {
    if(!obj) {
      return; 
    }

    // now run exportElements
    //dom.exportElements(objs, fullImagesDir, name + '.png', name);

    var bounds = cloneAndCut(obj);
    var new_dom = createAndPaste(bounds);

    fw.exportDocumentAs(new_dom, fullImagesDir + name + '.png', null);

    new_dom.close(false);
    
  }
  FIB._exportPNG = exportPNG;

  var getActualSize = function getActualSize(obj) {
    var size = {};

    size.top = obj.top;
    size.left = obj.left;
    size.width = obj.width;
    size.height = obj.height;
    size.right = obj.left + obj.width;
    size.bottom = obj.top + obj.height;

    if (obj.pixelRect) {
      size.top = Math.min(size.top, obj.pixelRect.top);
      size.bottom = Math.max(size.bottom, obj.pixelRect.bottom);
      size.left = Math.min(size.left, obj.pixelRect.left);
      size.right = Math.max(size.right, obj.pixelRect.right);
      size.height = size.bottom - size.top;
      size.width = size.right - size.left;
    }

    return size;
  };
  FIB.getActualSize = getActualSize;

  // our recursive means of extracting objects
  var extractObjects = function (container, pageObj) {

    // initialize pageObj if need be
    if(pageObj === undefined) {
      pageObj = {};
    }

    // *TODO handle resorting of layers so objects show up properly
    
    // function to extract those basic properties
    var extractBasics = function (obj) {

      var newObj = {};
      var new_size = getActualSize(obj);

      newObj.left = new_size.left;
      newObj.top = new_size.top;

      // using auto here as height and width will
      // sometimes cause the image to expanded in improper ways
      newObj.height = "auto"; 
      newObj.width = "auto";

      // get meta data out of name and GO!
      // Small chance Titanium may someday use keyword metaData
      newObj.metaData = extractMetaData(obj.name);

      // set hidden attribute
      if (newObj.metaData && !obj.visible) {
        newObj.metaData.hidden = true;
      }
      if(newObj.metaData.name == 'bg_input') {
        console.log(new_size);
      }

      // now use meta data name if given.  Get unique if no name, or
      // empty, or doesn't exist
      if(newObj.metaData.name && 
         newObj.name != '' &&
         isNameUnique(newObj.metaData.name)) {

        newObj.name = newObj.metaData.name;
        delete newObj.metaData.name;
      } else {
        newObj.name = getUniqueName(obj);
      }
      
      // Set zIndex
      if(newObj.metaData.zIndex) {
        newObj.zIndex = newObj.metaData.zIndex;
      }
      
      // now add to name map
      nameMap[newObj.name] = true;

      return newObj;
    };

    var extractImageBasedObject = function (obj) {
      var newObj = extractBasics(obj);
      if(!newObj) {
        return null;
      }

      if (!newObj.metaData.type) {
        newObj.metaData.type = 'image';
      }
      newObj.image = imagesDir + newObj.name + '.png';
      
      // extract inactive image
      if (newObj.metaData.inactive) {
        newObj.backgroundDisabledImage = imagesDir + 
          newObj.metaData.inactive + '.png';
      }

      // handle case for different meta data
      var extractType = {};

      extractType['scroll'] = function() {
        newObj.name = 'scroll_view';
        newObj.width = obj.width;
        newObj.height = obj.height;

        delete newObj.image;
      };

      extractType['web'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;
        newObj.url = newObj.metaData.url;

        delete newObj.image;
      };

      extractType['button'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;
        
        newObj.backgroundImage = newObj.image;
        delete newObj.image;
      };

      extractType['switch'] = function () {
        newObj.width = obj.width;
        newObj.height = obj.height;
        newObj.value = false;
        delete newObj.image;
      };

      extractType['textfield'] = function() {

        // first export the text box
        newObj.left += 5;
        newObj.width = obj.width - 10;
        newObj.height = obj.height;

        // set background to transparent
        newObj.backgroundColor = 'transparent';

        
        // Set color from metadata
        if (newObj.metaData.color) {
          newObj.color = newObj.metaData.color;
        }
  
        // Set font from metadata
        if (newObj.metaData.font || newObj.metaData.fontsize) {
          newObj.font = {};
          if(newObj.metaData.font) {
            newObj.font.fontFamily = hackyFontRename(newObj.metaData.font);
          }
          if(newObj.metaData.fontsize) {
            newObj.font.fontSize = newObj.metaData.fontsize;
          }
        }

        delete newObj.image;
        exportPNG(obj, newObj.name);
        pageObj[newObj.name] = newObj;

        // then export an image behind it
        // since adding backgroundImage to a text label causes pain
        var newImgObj = extractBasics(obj);
        newImgObj.metaData.type = 'image';
        newImgObj.name = newObj.name + "_img";
        newImgObj.image = imagesDir + newImgObj.name + ".png";
        nameMap[newImgObj.name] = true;
        delete newImgObj.metaData.name;
        newObj = newImgObj;
      };
      
      extractType['textarea'] = extractType['textfield'];

      extractType['scrollable'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;
        newObj.contentWidth = 'auto';
        newObj.contentHeight = 'auto';

        if (obj.opacity != 0) {
          newObj.backgroundImage = newObj.image;
        }
        delete newObj.image;
      }

      extractType['table'] = extractType['scrollable'];

      extractType['free_image'] = function() {

        // if it's an instance, then we want to add an offset
        if (objType(obj) === 'Instance') {

          // get the transform
          var x = obj.transform.matrix[6];
          var y = obj.transform.matrix[7];

          // set how much to offset from the top, left
          newObj.metaData.offset = {
            x: newObj.left - x,
            y: newObj.top - y
          }
        }
      }
      
      extractType['progress'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;
        newObj.bgcolor = '#FFFFFF'; // Arbitrarily defaulted to white
        newObj.inverted = false;
        if (newObj.metaData.bgcolor) {
          newObj.bgcolor = newObj.metaData.bgcolor;
        }
        if (newObj.metaData.inverted) {
          newObj.inverted = newObj.metaData.inverted;
        }
      }

      // now run it
      if (newObj.metaData.type in extractType) {
        extractType[newObj.metaData.type]();
      }

      pageObj[newObj.name] = newObj;

      if (newObj.metaData.type != 'web' && 
          newObj.metaData.type != 'scroll') {
        exportPNG(obj, newObj.name);
      }

      return newObj;
    };

    // means of getting meta data out of name
    // *TODO create interface and store in symbol data.
    // using a string for this is a HACK
    var extractMetaData = function (metaString) {
      var metaData = null;
      var name;

      // null if given null
      if(!metaString || metaString === '') {
        return {};
      }

      // strip semicolons
      metaString = metaString.replace(/\;/g, "");

      if(!(metaString.match(/:/))) {
        metaString = metaString.replace(/\ /g, "_");
        return {name: metaString};
      }
      
      // try to make string safe for json input
      // THIS IS TOTALLY HACKY.  GET RID OF THIS
      // replace white space, and add quotes around all objects
      metaString = metaString.replace(/\ /g, "");
      metaString = metaString.replace(/:/g, "\":\"");
      metaString = metaString.replace(/,/g, "\",\"");
     
      // add starting and ending bracket-quotes
      metaString = "{\"" + metaString + "\"}";

      // try getting metadata.  Quite possible you could fail
      try {
        metaData = dojo.fromJson(metaString);
      } catch (e) {
        // *TODO let user know if something crappy happens when parsing
        console.log('Your Mom\'s poorly formatted string: ' + metaString)
      }
      return metaData;
    };
    FIB._extractMetaData = extractMetaData;

    // extraction functions for different types of objects stored here
    extractSwitch = {};

    // how to handle groups
    extractSwitch['Group'] = function (obj) {

      // exporting group as image for now
      return extractImageBasedObject(obj);
    };

    // How to handle Image 
    extractSwitch['Image'] = function (obj) {
      // extract as basic image for now
      return extractImageBasedObject(obj);
    };

    // How to handle Image 
    extractSwitch['Instance'] = function (obj) {
      // extract as basic image for now
      var newObj = extractImageBasedObject(obj);

      var origin_offset = {};
      return newObj;
    };

    // How to handle Layers
    extractSwitch['Layer'] = function (obj) {
      if(obj.layerType !== 'web') {
        extractObjects(obj.elems, pageObj);
      }
      return null;
    };

    // How to handle paths
    extractSwitch['Path'] = function (obj) {
      // extract as basic image for now
      return extractImageBasedObject(obj);
    };

    // How to Rectangle Primitives
    extractSwitch['RectanglePrimitive'] = function (obj) {
      // extract as basic image for now
      return extractImageBasedObject(obj);
    };

    // How to handle text objects
    extractSwitch['Text'] = function (obj) {
      var newObj = extractBasics(obj);
      if (!newObj) {
        return null;
      }
			
      newObj.width = obj.width;
      newObj.height = obj.height;
      newObj.textAlign = obj.alignment;
      newObj.color = obj.pathAttributes.fillColor;
      newObj.font = {
        fontFamily: obj.font,
        fontSize: obj.fontsize
      };

      newObj.font.fontFamily = hackyFontRename(newObj.font.fontFamily);
      
      // handle textfield... all others are labels
      if (newObj.metaData.type == 'textfield') {

        newObj.value = obj.textChars;
      } else if (newObj.metaData.type == 'textarea') {
        newObj.value = obj.textChars;
      } else {
        newObj.metaData.type = 'label';
        newObj.text = obj.textChars;
      }

      pageObj[newObj.name] = newObj;

      return newObj;
    };

    // extract switch helper
    var extractObject = function (obj) {
      var type = objType(obj);
      if (!(type in extractSwitch)) {
        return null;
      }
      return extractSwitch[objType(obj)](obj);
    };

    // wrapper for the map call of extract object
    _.map(container, extractObject);
    return pageObj;
  }
  // extractObjects added for testing purposes
  FIB._extractObjects = extractObjects;

  // What type of view are we dealing with here?
  var extractViewProps = function extractViewProps(obj_tree) {
    var props = {};

    props.metaData = {};
    props.metaData.type = 'view';

    props.backgroundColor = dom.backgroundColor;

    props.metaData.orientation = 'PORTRAIT'; 

    props.height = dom.height;
    props.width = dom.width;

    var v_max = VERT_SCROLL_THRESHOLD;
    var h_max = HORIZ_SCROLL_THRESHOLD;
    
    // *TODO make this based on meta data in png file, not a name
    if (dom.pageName.match(/TableRow$/)) {
      props.metaData.type = 'tableRow';
    }

    if (dom.width > dom.height && dom.width > h_max) {
      props.metaData.orientation = 'LANDSCAPE'; 
    }

    // add scroll view
    if (obj_tree && obj_tree.scroll_view) {
      props.metaData.type = 'scroll';
      props.contentHeight = dom.height;
      props.contentWidth = dom.width;
      props.height = obj_tree.scroll_view.height;
      props.width = obj_tree.scroll_view.width;
    }


    return props;
  };
  FIB._extractViewProps = extractViewProps;

  // The actual function you call to export a page
  FIB.exportInterface = function () {
    // get root resource directory
    if(!dom || !getResourceDirs()) {
      return false;
    }
    
    // delete the image directory first
    Files.deleteFileIfExisting(fullImagesDir); 
    Files.createDirectory(fullImagesDir);

    var objTree = extractObjects(dom.topLayers || dom.layers);

    objTree._props = extractViewProps(objTree);
    
    // delete scroll_view if it exists
    if (objTree.scroll_view) {
      delete objTree.scroll_view;
    }

    // Create file, then open.  Need to add test to check for file first
    // and delete if exists.
    var filename = page_name + '.json';
    
    Files.deleteFileIfExisting(fullStylesDir + filename);
    Files.createFile(fullStylesDir + filename, 'json', 'FWMX');
    var file = Files.open(fullStylesDir + filename, true);

    // Make sure you write text in UTF8!
    file.writeUTF8(dojo.toJson(objTree, true, '  '));
    file.close();
  };
})();

// only export if this is a test
if (fw._mockFile) {
  exports.FIB = FIB;
}

try {
  // don't run this if you're testing it
  if(!fw._mockFile) {
    var ret = FIB.exportInterface();
    /*
    var bounds = FIB._cloneAndCut(fw.selection[0]);
    console.log(bounds);
    FIB._createAndPaste(bounds);
    fw.selection[0]
    */
  }
} catch(e) {
  alert([e.lineNumber, e.message]);
};
