if ( typeof dojo === 'undefined' )
  fw.runScript( fw.currentScriptDir + '/lib/lib.js' )

dojo.require( 'underscore' )
dojo.require( 'fib_helper' )
dojo.require( 'dojo._base.json' )

Array.isArray = Array.isArray ||
  function(o) {
    return Object.prototype.toString.call(o) === '[object Array]'
  }

var FIB = {}

;( function () {

  var VERT_SCROLL_THRESHOLD = 480
  var HORIZ_SCROLL_THRESHOLD = 320

  var dom = fw.getDocumentDOM()
  var sel = fw.selection

  // Support for our hacky font renaming to get around UIFont limitation
  // on number of weights/styles per font family to 2. Used ttx to
  // rename fonts with their weights -
  // i.e. Gotham-Bold-Italic -> GothamBoldItalic
  var hackyFonts = [ 'Gotham' ]
  var hackyFontRename = function hackyFontRename( font ) {
    for ( var i = 0; i < hackyFonts.length; i++ ) {
      if ( 0 === font.indexOf( hackyFonts[i] ) )
        return font.replace( /-/g, '' )
    }
    return font
  }

  // function to extract those basic properties
  var extractBasics = function ( fwObj, parent ) {

    var outObj        = {}
    ,   outSize       = FibHelper.getActualSize( fwObj )
    ,   parentOutSize = parent ? FibHelper.getActualSize( parent ) : undefined

    outObj.left = outSize.left - (parentOutSize ? parentOutSize.left : 0)
    outObj.top = outSize.top - (parentOutSize ? parentOutSize.top : 0)

    outObj.height = outSize.height
    outObj.width = outSize.width

    metadata = parseMetadata( fwObj.name )
    
    _.extend( outObj, metadata )

    if( !metadata.id || outObj.id == '' )
      outObj.id = FibHelper.getUniqueName( fwObj )
    
    FibHelper.nameMap[ outObj.id ] = true

    return outObj
  }

  var extractImageBasedObject = function ( fwObj, parent ) {
    var outObj = extractBasics( fwObj, parent )

    console.log( 'image being exported: ' + fwObj.name )

    if ( !outObj ) return null

    if ( !outObj.type ) outObj.type = 'image'

    outObj.image = FibHelper.imagesDir + outObj.id + '.png'
    
    if ( outObj.inactive ) {
      outObj.backgroundDisabledImage = FibHelper.imagesDir + 
        outObj.inactive + '.png'
    }

    var extractImageHandlers = {}

    extractImageHandlers[ 'scroll' ] = function() {
      // Is this still used?
      outObj.id = 'scroll_view'
      delete outObj.image
    }

    extractImageHandlers[ 'web' ] = function() {
      delete outObj.image
    }

    extractImageHandlers[ 'button' ] = function() {
      outObj.backgroundImage = outObj.image
      delete outObj.image
    }

    extractImageHandlers[ 'switch' ] = function () {
      outObj.value = false
      delete outObj.image
    }

    extractImageHandlers[ 'textfield' ] = function() {
      outObj.left += 5
      outObj.width = fwObj.width - 10

      outObj.backgroundColor = 'transparent'
      
      if ( outObj.font || outObj.fontsize ) {
        var fontFamily = outObj.font
        outObj.font = {}

        if ( fontFamily )
          outObj.font.fontFamily = fontFamily

        if( outObj.fontsize ) {
          outObj.font.fontSize = outObj.fontsize
          delete outObj.fontsize
        }
      }

      delete outObj.image
      FibHelper.exportPNG( fwObj, outObj.id ) // This line may not be necessary

      var outImgObj = extractBasics( fwObj, parent )

      delete outImgObj.font
      delete outImgObj.fontsize

      outImgObj.type = 'image'
      outImgObj.id = outObj.id + "_img"
      outImgObj.image = FibHelper.imagesDir + outImgObj.id + ".png"

      FibHelper.nameMap[ outImgObj.id ] = true
      FibHelper.exportPNG( fwObj, outImgObj.id )

      outObj = [ outImgObj, outObj ]
    }

    extractImageHandlers[ 'textarea' ] = extractImageHandlers[ 'textfield' ]

    extractImageHandlers[ 'scrollable' ] = function() {
      outObj.contentWidth = 'auto'
      outObj.contentHeight = 'auto'

      if ( fwObj.opacity != 0 )
        outObj.backgroundImage = outObj.image

      delete outObj.image
    }

    extractImageHandlers[ 'table' ] = extractImageHandlers[ 'scrollable' ]

    if (outObj.type in extractImageHandlers)
      extractImageHandlers[ outObj.type ]()

    if ( outObj.type != 'web' && 
         outObj.type != 'scroll' ) {
      FibHelper.exportPNG( fwObj, outObj.id )
    }
    
    if (outObj.type == 'free_image' )
      outObj = undefined

    return outObj
  }

  var parseMetadata = function ( metaString ) {
    var metadata = null
    var name

    if( !metaString || metaString === '' ) return {}

    metaString = metaString.replace( /\;/g, '' )

    if( !(metaString.match( /:/ ))) {
      metaString = metaString.replace( /\ /g, '_' )
      return { id: metaString }
    }
    
    metaString = metaString.replace( /\ /g, '' )
    metaString = metaString.replace( /:/g, '\":\"' )
    metaString = metaString.replace( /,/g, '\",\"' )
   
    metaString = '{\"' + metaString + '\"}'

    try {
      metadata = dojo.fromJson( metaString )
    } catch ( e ) {
      alert( 'Your Mom\'s poorly formatted string: ' + metaString )
    }

    return metadata
  }
  FIB._parseMetadata = parseMetadata

  var fwTypeHandlers = {}

  var createFWTypeHandlers = function () {
    fwTypeHandlers[ 'Layer' ] = function ( fwObj, parent ) {

      if ( fwObj.layerType !== 'web' ) {
        return extractObjects( fwObj.elems, parent )
      }
      return []
    }
    
    fwTypeHandlers[ 'Group' ] = function ( fwObj, parent ) {

      var outObj = extractBasics( fwObj, parent )

      if (  outObj.type === 'textfield' ||
            outObj.type === 'free_image' ||
            outObj.type === 'button' ) {

        outObj = extractImageBasedObject( fwObj, parent )

      } else {

        if ( !outObj.type ) outObj.type = 'view'
        
        outObj.children = []

        _(fwObj.elements).each( function ( element ) {
          outObj.children.unshift( extractObject( element, fwObj ))
        })
      }

      return outObj
    }

    var exportVectorAsImage = function( fwObj ) {

      var metadata = parseMetadata( fwObj.name )
      var exportAsImage = false
      if ( metadata.type === 'textfield' || metadata.type === 'free_image' ) {
        // Just export it as an image-based object until we rework
        // textfields properly as an add-on instead of a basic type
        exportAsImage = true
      } else if ( fwObj.pathAttributes.fill &&
                  (( fwObj.pathAttributes.fill.name !== 'Solid' ) ||
                   ( fwObj.pathAttributes.fill.textureBlend > 0 ))) {
        exportAsImage = true
      }
      return exportAsImage
    }

    fwTypeHandlers[ 'Path' ] = function ( fwObj, parent ) {
      var outObj

      if ( exportVectorAsImage( fwObj )) {
        outObj = extractImageBasedObject( fwObj, parent )
      } else {
        outObj = extractBasics( fwObj, parent )
        outObj.type = 'canvas'

        var parentOutSize = parent
          ? FibHelper.getActualSize( parent )
          : undefined

        var canvasLeft = (parentOutSize ? parentOutSize.left : 0 )
          + outObj.left
        ,   canvasTop = (parentOutSize ? parentOutSize.top : 0 )
          + outObj.top

        if ( fwObj.contours.length > 1)
          return extractImageBasedObject( fwObj, parent )

        outObj.drawList = []
        _(fwObj.contours).each( function ( contour ) {
          var nodes = contour.nodes

          var outContour =  {
            type: 'curve',
            close: contour.isClosed,
            points: []
          }

          if ( fwObj.pathAttributes.brush ) {
            outContour.color =  fwObj.pathAttributes.brushColor,
            outContour.linewidth = fwObj.pathAttributes.brush.diameter
          }

          if ( fwObj.pathAttributes.fill )
            outContour.background = fwObj.pathAttributes.fillColor


          _(nodes).each( function ( point ) {
            var p = {
              x: point.x - canvasLeft,
              y: point.y - canvasTop,
              predX: point.predX - canvasLeft,
              predY: point.predY - canvasTop,
              succX: point.succX - canvasLeft,
              succY: point.succY - canvasTop
            }
            outContour.points.push( p )
          })

          outObj.drawList.push( outContour )
        })
      } 

      return outObj
    }

    fwTypeHandlers[ 'RectanglePrimitive' ] = function ( fwObj, parent ) {
      var outObj

      if ( exportVectorAsImage( fwObj )) {
        outObj = extractImageBasedObject( fwObj, parent )
      } else {
        outObj = extractBasics( fwObj, parent )
        outObj.type = 'canvas'

        outObj.drawList = []
        var outContour =  {
          type: 'rect',
          background: fwObj.pathAttributes.fillColor,
          color: fwObj.pathAttributes.brushColor,
          lineWidth: fwObj.pathAttributes.brush
            ? fwObj.pathAttributes.brush.diameter : 0,
          x: 0,
          y: 0,
          width: outObj.width,
          height: outObj.height
        }
        outObj.drawList.unshift( outContour )
      }

      return outObj
    }

    fwTypeHandlers[ 'Text' ] = function ( fwObj, parent ) {
      var outObj = extractBasics( fwObj, parent )

      if ( !outObj ) return null
      
      outObj.textAlign = fwObj.alignment
      outObj.color = fwObj.pathAttributes.fillColor
      outObj.font = {
        fontFamily: fwObj.font,
        fontSize: fwObj.fontsize
      }

      if ( outObj.type == 'textfield' ) {
        outObj.value = fwObj.textChars
      } else if ( outObj.type == 'textarea' ) {
        outObj.value = fwObj.textChars
      } else {
        outObj.type = 'label'
        outObj.text = fwObj.textChars
      }

      return outObj
    }
  }
  
  createFWTypeHandlers()

  var extractObject = function ( fwObj, parent ) {
    var fwType = FibHelper.objType( fwObj )
    ,   metadata = parseMetadata( fwObj.name )
    ,   outObj

    if ( !( fwType in fwTypeHandlers ) || metadata.flatten)
      outObj = extractImageBasedObject( fwObj, parent )
    else
      outObj = fwTypeHandlers[ fwType ]( fwObj, parent )


    if ( Array.isArray( outObj )) {
      _(outObj).each( function ( obj ) {
        if ( obj && obj.font )
          obj.font.fontFamily = hackyFontRename( obj.font.fontFamily )
      })
    } else {
        if ( outObj && outObj.font )
          outObj.font.fontFamily = hackyFontRename( outObj.font.fontFamily )
    }
    return outObj
  }


  var extractObjects = function ( fwContainer, parent ) {
    var result = []

    _.map(fwContainer, function( fwObj ) {
      var outObj = extractObject( fwObj, parent )
      if ( outObj ) {
        result.unshift( outObj )
      }
    })
    return _(result).flatten()
  }
  FIB._extractObjects = extractObjects

  FIB.exportInterface = function () {
    if( !dom || !FibHelper.getResourceDirs()) return false
    
    Files.deleteFileIfExisting( FibHelper.fullImagesDir )
    Files.createDirectory( FibHelper.fullImagesDir )

    var objTree = extractObjects( dom.topLayers || dom.layers )
    
    var filename = FibHelper.getPageName() + '.json'
    
    Files.deleteFileIfExisting( FibHelper.fullJSONDir + filename )
    Files.createFile( FibHelper.fullJSONDir + filename, 'json', 'FWMX' )
    var file = Files.open( FibHelper.fullJSONDir + filename, true )

    file.writeUTF8(dojo.toJson( objTree, true, '  ' ))
    file.close()
  }
})()

if ( fw._mockFile ) exports.FIB = FIB

try {
  if( !fw._mockFile ) FIB.exportInterface()
} catch(e) {
  alert([ e.lineNumber, e.message ])
}
