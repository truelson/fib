/* File: fib.jsf
 * Authors: Palmer Truelson and Aza Raskin
 * Company: Massive Health, LLC
 * Licence: $LICENSE
 * About: Fireworks Interface Builder.  A fireworks extension script that
 *  exports json data to be used as interface description for Titanium
 *  mobile apps.
 */

// Make sure we have dojo
try { dojo.require; } catch (e)
    { fw.runScript(fw.currentScriptDir + "/lib/lib.js"); }

try { _.times(function() {}) } catch (e)
    { fw.runScript(fw.currentScriptDir + "/lib/underscore.js"); }

fw.runScript(fw.currentScriptDir + '/fib_helper.js')

dojo.require("dojo._base.json");

var FIB = {};

(function () {

  // CONSTS
  var VERT_SCROLL_THRESHOLD = 480;
  var HORIZ_SCROLL_THRESHOLD = 320;

  // Setup.  Here comes the dom tree
  var dom = fw.getDocumentDOM();
  var sel = fw.selection;

  // Support for our hacky font renaming to get around UIFont limitation on number
  // of weights/styles per font family to 2. Used ttx to rename fonts with their
  // weights - i.e. Gotham-Bold-Italic -> GothamBoldItalic
  var hackyFonts = ['Gotham'];
  var hackyFontRename = function hackyFontRename(font) {
    for (var i = 0; i < hackyFonts.length; i++) {
      if (0 === font.indexOf(hackyFonts[i])) {
        return font.replace(/-/g,'');
      }
    }
    return font;
  }

  // our recursive means of extracting objects
  var extractObjects = function (container, pageObj) {

    // initialize pageObj if need be
    if(pageObj === undefined) {
      pageObj = [];
    }

    // *TODO handle resorting of layers so objects show up properly
    
    // function to extract those basic properties
    var extractBasics = function (obj) {

      var newObj = {};
      var new_size = FibHelper.getActualSize(obj);

      newObj.left = new_size.left;
      newObj.top = new_size.top;

      // using auto here as height and width will
      // sometimes cause the image to expanded in improper ways
      newObj.height = new_size.height; 
      newObj.width = new_size.width;

      metaData = extractMetaData(obj.name);
      
      _.extend(newObj, metaData)

      // now use meta data name if given.  Get unique if no name, or
      // empty, or doesn't exist
      if(!metaData.id ||
         newObj.id == '' ||
         !FibHelper.isNameUnique(newObj.id))
      {
        newObj.id = FibHelper.getUniqueName(obj)
      }
      
      // now add to name map
      FibHelper.nameMap[newObj.id] = true;

      return newObj;
    };

    var extractImageBasedObject = function (obj) {
      var newObj = extractBasics(obj);
      if(!newObj) {
        return null;
      }

      if (!newObj.type) {
        newObj.type = 'image';
      }
      newObj.image = FibHelper.imagesDir + newObj.id + '.png';
      
      // extract inactive image
      if (newObj.inactive) {
        newObj.backgroundDisabledImage = FibHelper.imagesDir + 
          newObj.inactive + '.png';
      }

      // handle case for different meta data
      var extractType = {};

      extractType['scroll'] = function() {
        newObj.id = 'scroll_view';
        newObj.width = obj.width;
        newObj.height = obj.height;

        delete newObj.image;
      };

      extractType['web'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;

        delete newObj.image;
      };

      extractType['button'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;
        
        newObj.backgroundImage = newObj.image;
        delete newObj.image;
      };

      extractType['switch'] = function () {
        newObj.width = obj.width;
        newObj.height = obj.height;
        newObj.value = false;
        delete newObj.image;
      };

      extractType['textfield'] = function() {

        // first export the text box
        newObj.left += 5;
        newObj.width = obj.width - 10;
        newObj.height = obj.height;

        // set background to transparent
        newObj.backgroundColor = 'transparent';

        
        // Set font from metadata
        if (newObj.font || newObj.fontsize) {
          var oldFont = newObj.font;
          var oldFontSize = newObj.fontsize;
          newObj.font = {};
          if(oldFont) {
            newObj.font.fontFamily = hackyFontRename(oldFont);
          }
          if(oldFontSize) {
            newObj.font.fontSize = oldFontSize;
            delete newObj.fontsize;
          }
        }

        delete newObj.image
        FibHelper.exportPNG( obj, newObj.id )
        pageObj.push( newObj )

        // then export an image behind it
        // since adding backgroundImage to a text label causes pain
        var newImgObj = extractBasics(obj);
        newImgObj.type = 'image';
        newImgObj.id = newObj.id + "_img";
        newImgObj.image = FibHelper.imagesDir + newImgObj.id + ".png";
        FibHelper.nameMap[newImgObj.id] = true;
        newObj = newImgObj;
      };
      
      extractType['textarea'] = extractType['textfield'];

      extractType['scrollable'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;
        newObj.contentWidth = 'auto';
        newObj.contentHeight = 'auto';

        if (obj.opacity != 0) {
          newObj.backgroundImage = newObj.image;
        }
        delete newObj.image;
      }

      extractType['table'] = extractType['scrollable'];

      extractType['free_image'] = function() { }
      
      extractType['progress'] = function() {
        newObj.width = obj.width;
        newObj.height = obj.height;
        if(!newObj.bgcolor) {
          newObj.bgcolor = '#FFFFFF'; // Arbitrarily defaulted to white
        }
        if(newObj.inverted === 'true') {
          newObj.inverted = true;
        } else {
          newObj.inverted = false;
        }
      }

      // now run it
      if (newObj.type in extractType) {
        extractType[newObj.type]();
      }

      if (newObj.type != 'free_image') {
        pageObj.push( newObj )
      }

      if (newObj.type != 'web' && 
          newObj.type != 'scroll') {
        FibHelper.exportPNG(obj, newObj.id);
      }

      return newObj;
    };

    var extractMetaData = function (metaString) {
      var metaData = null;
      var name;

      // null if given null
      if(!metaString || metaString === '') {
        return {};
      }

      // strip semicolons
      metaString = metaString.replace(/\;/g, "");

      if(!(metaString.match(/:/))) {
        metaString = metaString.replace(/\ /g, "_");
        return {id: metaString};
      }
      
      metaString = metaString.replace(/\ /g, "");
      metaString = metaString.replace(/:/g, "\":\"");
      metaString = metaString.replace(/,/g, "\",\"");
     
      // add starting and ending bracket-quotes
      metaString = "{\"" + metaString + "\"}";

      // try getting metadata.  Quite possible you could fail
      try {
        metaData = dojo.fromJson(metaString);
      } catch (e) {
        // *TODO let user know if something crappy happens when parsing
        console.log('Your Mom\'s poorly formatted string: ' + metaString)
      }
      return metaData;
    };
    FIB._extractMetaData = extractMetaData;

    // extraction functions for different types of objects stored here
    extractSwitch = {};

    // how to handle groups
    extractSwitch['Group'] = function (obj) {

      // exporting group as image for now
      return extractImageBasedObject(obj);
    };

    // How to handle Image 
    extractSwitch['Image'] = function (obj) {
      // extract as basic image for now
      return extractImageBasedObject(obj);
    };

    // How to handle Image 
    extractSwitch['Instance'] = function (obj) {
      // extract as basic image for now
      var newObj = extractImageBasedObject(obj);

      var origin_offset = {};
      return newObj;
    };

    // How to handle Layers
    extractSwitch['Layer'] = function (obj) {
      if(obj.layerType !== 'web') {
        extractObjects(obj.elems, pageObj);
      }
      return null;
    };

    // How to handle paths
    extractSwitch['Path'] = function (obj) {
      // extract as basic image for now
      return extractImageBasedObject(obj);
    };

    // How to Rectangle Primitives
    extractSwitch['RectanglePrimitive'] = function (obj) {
      // extract as basic image for now
      return extractImageBasedObject(obj);
    };

    // How to handle text objects
    extractSwitch['Text'] = function (obj) {
      var newObj = extractBasics(obj);
      if (!newObj) {
        return null;
      }
			
      newObj.width = obj.width;
      newObj.height = obj.height;
      newObj.textAlign = obj.alignment;
      newObj.color = obj.pathAttributes.fillColor;
      newObj.font = {
        fontFamily: obj.font,
        fontSize: obj.fontsize
      };

      newObj.font.fontFamily = hackyFontRename(newObj.font.fontFamily);
      
      // handle textfield... all others are labels
      if (newObj.type == 'textfield') {

        newObj.value = obj.textChars;
      } else if (newObj.type == 'textarea') {
        newObj.value = obj.textChars;
      } else {
        newObj.type = 'label';
        newObj.text = obj.textChars;
      }

      pageObj.push( newObj )

      return newObj;
    };

    // extract switch helper
    var extractObject = function (obj) {
      var type = FibHelper.objType(obj);
      if (!(type in extractSwitch)) {
        return null;
      }
      return extractSwitch[FibHelper.objType(obj)](obj);
    };

    // wrapper for the map call of extract object
    _.map(container, extractObject);
    return pageObj;
  }
  // extractObjects added for testing purposes
  FIB._extractObjects = extractObjects;

  // The actual function you call to export a page
  FIB.exportInterface = function () {
    // get root resource directory
    if(!dom || !FibHelper.getResourceDirs()) {
      return false;
    }
    
    // delete the image directory first
    Files.deleteFileIfExisting(FibHelper.fullImagesDir); 
    Files.createDirectory(FibHelper.fullImagesDir);

    var objTree = extractObjects(dom.topLayers || dom.layers);

    objTree.reverse();

    // Create file, then open.  Need to add test to check for file first
    // and delete if exists.
    var filename = FibHelper.getPageName() + '.json';
    
    Files.deleteFileIfExisting(FibHelper.fullJSONDir + filename);
    Files.createFile(FibHelper.fullJSONDir + filename, 'json', 'FWMX');
    var file = Files.open(FibHelper.fullJSONDir + filename, true);

    // Make sure you write text in UTF8!
    file.writeUTF8(dojo.toJson(objTree, true, '  '));
    file.close();
  };
})();

// only export if this is a test
if (fw._mockFile) {
  exports.FIB = FIB;
}

try {
  // don't run this if you're testing it
  if(!fw._mockFile) {
    var ret = FIB.exportInterface();
  }
} catch(e) {
  alert([e.lineNumber, e.message]);
};
